// Copyright 2018 Developers of the Rand project.
// Copyright 2013 The Rust Project Developers.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A wrapper around another PRNG that reseeds it after it
//! generates a certain number of random bytes.

use core::convert::Infallible;
use core::mem::size_of_val;

use rand_core::block::{BlockRng, CryptoGenerator, Generator};
use rand_core::{SeedableRng, TryCryptoRng, TryRng};

/// A wrapper around any PRNG that implements [`Generator`], that adds the
/// ability to reseed it.
#[derive(Debug)]
pub struct ReseedingRng<G, Rsdr>(BlockRng<ReseedingCore<G, Rsdr>>)
where
    G: Generator + SeedableRng,
    Rsdr: TryRng;

impl<const N: usize, G, Rsdr> ReseedingRng<G, Rsdr>
where
    G: Generator<Output = [u32; N]> + SeedableRng,
    Rsdr: TryRng,
{
    /// Create a new `ReseedingRng` from an existing PRNG, combined with a RNG
    /// to use as reseeder.
    ///
    /// `threshold` sets the number of generated bytes after which to reseed the
    /// PRNG. Set it to zero to never reseed based on the number of generated
    /// values.
    pub fn new(threshold: u64, reseeder: Rsdr) -> Result<Self, Rsdr::Error> {
        Ok(ReseedingRng(BlockRng::new(ReseedingCore::new(
            threshold, reseeder,
        )?)))
    }

    /// Immediately reseed the generator
    ///
    /// This discards any remaining random data in the cache.
    pub fn reseed(&mut self) -> Result<(), Rsdr::Error> {
        self.0.reset_and_skip(0);
        self.0.core.reseed()
    }
}

// TODO: this should be implemented for any type where the inner type
// implements TryRng, but we can't specify that because ReseedingCore is private
impl<const N: usize, G, Rsdr> TryRng for ReseedingRng<G, Rsdr>
where
    G: Generator<Output = [u32; N]> + SeedableRng,
    Rsdr: TryRng,
{
    type Error = Infallible;

    #[inline(always)]
    fn try_next_u32(&mut self) -> Result<u32, Infallible> {
        Ok(self.0.next_word())
    }

    #[inline(always)]
    fn try_next_u64(&mut self) -> Result<u64, Infallible> {
        Ok(self.0.next_u64_from_u32())
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Infallible> {
        self.0.fill_bytes(dest);
        Ok(())
    }
}

impl<const N: usize, G, Rsdr> TryCryptoRng for ReseedingRng<G, Rsdr>
where
    G: Generator<Output = [u32; N]> + SeedableRng + CryptoGenerator,
    Rsdr: TryCryptoRng,
{
}

#[derive(Debug)]
struct ReseedingCore<G, Rsdr> {
    inner: G,
    reseeder: Rsdr,
    threshold: i64,
    bytes_until_reseed: i64,
}

impl<G, Rsdr> Generator for ReseedingCore<G, Rsdr>
where
    G: Generator + SeedableRng,
    Rsdr: TryRng,
{
    type Output = <G as Generator>::Output;

    fn generate(&mut self, results: &mut Self::Output) {
        if self.bytes_until_reseed <= 0 {
            // We get better performance by not calling only `reseed` here
            // and continuing with the rest of the function, but by directly
            // returning from a non-inlined function.
            return self.reseed_and_generate(results);
        }
        let num_bytes = size_of_val(results);
        self.bytes_until_reseed -= num_bytes as i64;
        self.inner.generate(results);
    }
}

impl<G, Rsdr> ReseedingCore<G, Rsdr>
where
    G: Generator + SeedableRng,
    Rsdr: TryRng,
{
    /// Create a new `ReseedingCore`.
    ///
    /// `threshold` is the maximum number of bytes produced by
    /// [`Generator::generate`] before attempting reseeding.
    fn new(threshold: u64, mut reseeder: Rsdr) -> Result<Self, Rsdr::Error> {
        // Because generating more values than `i64::MAX` takes centuries on
        // current hardware, we just clamp to that value.
        // Also we set a threshold of 0, which indicates no limit, to that
        // value.
        let threshold = if threshold == 0 {
            i64::MAX
        } else if threshold <= i64::MAX as u64 {
            threshold as i64
        } else {
            i64::MAX
        };

        let inner = G::try_from_rng(&mut reseeder)?;

        Ok(ReseedingCore {
            inner,
            reseeder,
            threshold,
            bytes_until_reseed: threshold,
        })
    }

    /// Reseed the internal PRNG.
    fn reseed(&mut self) -> Result<(), Rsdr::Error> {
        G::try_from_rng(&mut self.reseeder).map(|result| {
            self.bytes_until_reseed = self.threshold;
            self.inner = result
        })
    }

    #[inline(never)]
    fn reseed_and_generate(&mut self, results: &mut G::Output) {
        trace!("Reseeding RNG (periodic reseed)");

        let num_bytes = size_of_val(results);

        if let Err(e) = self.reseed() {
            warn!("Reseeding RNG failed: {}", e);
            let _ = e;
        }

        self.bytes_until_reseed = self.threshold - num_bytes as i64;
        self.inner.generate(results);
    }
}

impl<G, Rsdr> CryptoGenerator for ReseedingCore<G, Rsdr>
where
    G: Generator + SeedableRng + CryptoGenerator,
    Rsdr: TryCryptoRng,
{
}

#[cfg(feature = "std_rng")]
#[cfg(test)]
mod test {
    use crate::RngExt;
    use crate::rngs::std::Core;
    use crate::test::const_rng;

    use super::ReseedingRng;

    #[test]
    fn test_reseeding() {
        let zero = const_rng(0);
        let thresh = 1; // reseed every time the buffer is exhausted
        let mut reseeding = ReseedingRng::<Core, _>::new(thresh, zero).unwrap();

        // RNG buffer size is [u32; 64]
        // Debug is only implemented up to length 32 so use two arrays
        let mut buf = ([0u32; 32], [0u32; 32]);
        reseeding.fill(&mut buf.0);
        reseeding.fill(&mut buf.1);
        let seq = buf;
        for _ in 0..10 {
            reseeding.fill(&mut buf.0);
            reseeding.fill(&mut buf.1);
            assert_eq!(buf, seq);
        }
    }
}
