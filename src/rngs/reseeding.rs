// Copyright 2018 Developers of the Rand project.
// Copyright 2013 The Rust Project Developers.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A wrapper around another PRNG that reseeds it after it
//! generates a certain number of random bytes.

use core::mem::size_of_val;
use rand_core::{CryptoRng, RngCore, SeedableRng, TryCryptoRng, TryRngCore};

/// A wrapper around any PRNG that implements [`BlockRngCore`], that adds the
/// ability to reseed it.
///
/// `ReseedingRng` reseeds the underlying PRNG in the following cases:
///
/// - On a manual call to [`reseed()`].
/// - After the PRNG has generated a configurable number of random bytes.
///
/// # When should reseeding after a fixed number of generated bytes be used?
///
/// Reseeding after a fixed number of generated bytes is never strictly
/// *necessary*. Cryptographic PRNGs don't have a limited number of bytes they
/// can output, or at least not a limit reachable in any practical way. There is
/// no such thing as 'running out of entropy'.
///
/// Occasionally reseeding can be seen as some form of 'security in depth'. Even
/// if in the future a cryptographic weakness is found in the CSPRNG being used,
/// or a flaw in the implementation, occasionally reseeding should make
/// exploiting it much more difficult or even impossible.
///
/// Use [`ReseedingRng::new`] with a `threshold` of `0` to disable reseeding
/// after a fixed number of generated bytes.
///
/// # Error handling
///
/// Although unlikely, reseeding the wrapped PRNG can fail. `ReseedingRng` will
/// never panic but try to handle the error intelligently through some
/// combination of retrying and delaying reseeding until later.
/// If handling the source error fails `ReseedingRng` will continue generating
/// data from the wrapped PRNG without reseeding.
///
/// Manually calling [`reseed()`] will not have this retry or delay logic, but
/// reports the error.
///
/// # Example
///
/// ```
/// use chacha20::ChaCha20Rng; // Internal part of ChaChaRng that
///                             // implements BlockRngCore
/// use rand::prelude::*;
/// use rand::rngs::OsRng;
/// use rand::rngs::ReseedingRng;
///
/// let mut reseeding_rng = ReseedingRng::<ChaCha20Rng, _>::new(0, OsRng).unwrap();
///
/// println!("{}", reseeding_rng.random::<u64>());
/// ```
///
/// [`BlockRngCore`]: rand_core::block::BlockRngCore
/// [`ReseedingRng::new`]: ReseedingRng::new
/// [`reseed()`]: ReseedingRng::reseed
#[derive(Debug)]
pub struct ReseedingRng<R, Rsdr>
where
    R: RngCore + SeedableRng,
    Rsdr: TryRngCore,
{
    prng: R,
    reseed_rng: Rsdr,
    threshold: i64,
    bytes_until_reseed: i64,
}

impl<R, Rsdr> ReseedingRng<R, Rsdr>
where
    R: RngCore + SeedableRng,
    Rsdr: TryRngCore,
{
    /// Create a new `ReseedingRng` from an existing PRNG, combined with a RNG
    /// to use as reseeder.
    ///
    /// `threshold` sets the number of generated bytes after which to reseed the
    /// PRNG. Set it to zero to never reseed based on the number of generated
    /// values.
    pub fn new(threshold: u64, mut reseed_rng: Rsdr) -> Result<Self, Rsdr::Error> {
        // Because generating more values than `i64::MAX` takes centuries on
        // current hardware, we just clamp to that value.
        // Also we set a threshold of 0, which indicates no limit, to that
        // value.
        let threshold = if threshold == 0 {
            i64::MAX
        } else if threshold <= i64::MAX as u64 {
            threshold as i64
        } else {
            i64::MAX
        };

        R::try_from_rng(&mut reseed_rng).map(|prng| Self {
            prng,
            reseed_rng,
            threshold,
            bytes_until_reseed: threshold,
        })
    }

    /// Immediately reseed the generator.
    ///
    /// This discards any remaining random data in the cache.
    pub fn reseed(&mut self) -> Result<(), Rsdr::Error> {
        self.prng = R::try_from_rng(&mut self.reseed_rng)?;
        Ok(())
    }

    fn reseed_check(&mut self, bytes: usize) {
        if self.bytes_until_reseed <= 0 {
            let res = self.reseed();
            if let Err(e) = res {
                warn!("Reseeding RNG failed: {e}");
            }
            self.bytes_until_reseed = self.threshold;
        }
        self.bytes_until_reseed -= bytes as i64;
    }
}

impl<R, Rsdr> RngCore for ReseedingRng<R, Rsdr>
where
    R: RngCore + SeedableRng,
    Rsdr: TryRngCore,
{
    #[inline(always)]
    fn next_u32(&mut self) -> u32 {
        self.reseed_check(size_of::<u32>());
        self.prng.next_u32()
    }

    #[inline(always)]
    fn next_u64(&mut self) -> u64 {
        self.reseed_check(size_of::<u64>());
        self.prng.next_u64()
    }

    #[inline]
    fn fill_bytes(&mut self, dst: &mut [u8]) {
        // Do not perform `reseed_check` for an empty `dst` to allow the compiler
        // to infer that we always generate PRNG data after reseeding.
        if dst.is_empty() {
            return;
        }
        self.reseed_check(size_of_val(dst));
        self.prng.fill_bytes(dst)
    }
}

impl<R, Rsdr> CryptoRng for ReseedingRng<R, Rsdr>
where
    R: CryptoRng + SeedableRng,
    Rsdr: TryCryptoRng,
{
}

#[cfg(feature = "std_rng")]
#[cfg(test)]
mod test {
    use crate::Rng;
    use crate::rngs::std::StdRng;
    use crate::test::const_rng;

    use super::ReseedingRng;

    #[test]
    fn test_reseeding() {
        let zero = const_rng(0);
        let thresh = 1; // reseed every time the buffer is exhausted
        let mut reseeding = ReseedingRng::<StdRng, _>::new(thresh, zero).unwrap();

        // RNG buffer size is [u32; 64]
        // Debug is only implemented up to length 32 so use two arrays
        let mut buf = ([0u32; 32], [0u32; 32]);
        reseeding.fill(&mut buf.0);
        reseeding.fill(&mut buf.1);
        let seq = buf;
        for _ in 0..10 {
            reseeding.fill(&mut buf.0);
            reseeding.fill(&mut buf.1);
            assert_eq!(buf, seq);
        }
    }
}
